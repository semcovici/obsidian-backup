

# Aula 23


![[aula23.pdf]]

## Dependabilidade

Um componente provê serviços para clientes. Para prover esses serviços, o componente pode precisar de serviços de outros componentes. Neste caso, o componente depende de outro(s) componente(s).

| Requisito         | Descrição                         |
|-------------------|-----------------------------------|
| **Disponibilidade** | Prontidão de uso                   |
| **Confiabilidade** | Continuidade do serviço            |
| **Segurança (Safety)** | Baixas chances de catástrofes     |
| **Manutenibilidade** | Facilidade de reparar uma falha |
### Confiabilidade x Disponibilidade

Confiabilidade R(t) de um componente C:
* definição: Probabilidade condicional de  C estar funcionando corretamente no intervalo \([0, t]\), dado que estava funcionando corretamente em T = 0.
* Métricas tradicionais:
	- **Mean Time To Failure (MTTF)**: tempo médio até que o componente falhe.
	- **Mean Time To Repair (MTTR)**: tempo médio de reparo.
	- **Mean Time Between Failures (MTBF)**: apenas \( \text{MTTF} + \text{MTTR} \).

---
Disponibilidade A(t) de um componente C:
* definição: Fraçāo média do tempo em que C esteve funcionando no intervalo \([0, t]\).
	* Disponibilidade de longo prazo A: A(∞)
	* $$A = MTTF/MTBF = MTTF/(MTTF + MTTR)$$

## Terminologia

| Termo               | Descrição                                                     | Exemplo               |
| ------------------- | ------------------------------------------------------------- | --------------------- |
| **Falha (failure)** | Um componente não está operando de acordo com a especificação | Programa deu crash    |
| **Erro**            | Parte do componente que pode levar a falhas                   | Bug na implementação  |
| **Defeito (fault)** | Causa do erro                                                 | Programador desatento |

Formas de lidar com defeitos:

| Termo                     | Descrição                                                                   | Exemplo                                                           |
| ------------------------- | --------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| **Prevenção de defeitos** | Evita a existência de defeito                                               | Não contratar programadores desatentos                            |
| **Tolerância a defeitos** | Componente capaz de mascarar a ocorrência de um defeito                     | Construir mais de uma versão do componente, de forma independente |
| **Remoção de defeitos**   | Reduzir a quantidade ou seriedade dos defeitos                              | Demitir os programadores desatentos                               |
| **Previsão de defeitos**  | Estimar a presença atual, incidência futura e as consequências dos defeitos | Estimar a quantidade de programadores desatentos contratados      |

Tipos de falhas:

## Tipos de falhas

| Tipo                                                               | Descrição do comportamento do servidor                                                                                 |
| ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| **Falha de parada (crash)**                                        | Para de funcionar, mas funcionava corretamente até parar                                                               |
| **Falha de omissão**<br><br>*Omissão de RX*<br>*Omissão de TX*<br> | Deixa de responder requisições<br><br><br>Falha em receber mensagens<br>Falha em enviar mensagens                      |
| **Falha temporal**                                                 | Resposta fora do prazo estabelecido                                                                                    |
| **Falha de resposta**<br><br>*Falha de valor*<br>*Falha de estado* | Resposta incorreta<br><br><br>O valor da resposta está incorreto<br>Desvio do fluxo de controle correto                |
| **Falha arbitrária**                                               | Possibilidade de gerar respostas arbitrárias em intervalos arbitrários, indetectável se a resposta está correta ou não |
### Dependabilidade x segurança

Falhas arbitrárias podem ser maliciosas. Pode-se fazer a seguinte distinção:
* Falha de omissão: um componente falha em realizar uma ação que deveria ter realizado
* Falha de ação: um componente realiza uma ação que não deveria ter realizado

Essas falhas são tipicamente problema de segurança. Distinguir entre falhas deliberadas (intencionais por uma entidade maliciosa) e falhas não intencionais é impossível, no caso geral.


### Falhas de parada

C não percebe mais nenhuma atividade de C*.
* É uma falha de parada (crash)? Falha de omissão (deixa de responder requisições)?ou falha temporal (resposta fora do prazo estabelecido)?
* pode ser impossível distinguir e descobrir qual falha estamos enfrentando.

Sistemas sincronos x assincronos:
- **Sistemas assíncronos:** Nada pode ser assumido a respeito da velocidade de execução dos processos ou sobre quando as mensagens serão entregues. Portanto, não é possível detectar falhas de parada de forma confiável.
- **Sistemas síncronos:** A velocidade de execução dos processos e o momento de entrega das mensagens são delimitados -> é possível dectar falhas de parada de forma confiável
- **Na prática, os sistemas são parcialmente síncronos:** Na maior parte do tempo, podemos assumir que o sistema é síncrono, porém os limites de tempo podem ser ocasionalmente violados. Assim, na maioria das vezes, é possível detectar falhas de parada (crashes) corretamente.

| Tipo de parada     | Descrição                                                      |
| ------------------ | -------------------------------------------------------------- |
| **Fail-stop**      | Falhas de parada, detectáveis de forma confiável               |
| **Fail-noisy**     | Falhas de parada, eventualmente detectáveis de forma confiável |
| **Fail-silent**    | Falhas de omissão ou crash: clientes não conseguem distinguir  |
| **Fail-safe**      | Falha arbitrária, porém benigna (i.e., não causarão dano)      |
| **Fail-arbitrary** | Falha arbitrária e maliciosa                                   |


## Mascarando falhas através de redundância
Tipos de redundancia:
- **Redundância de informação:** Adição de bits às unidades de dados de forma que o dado original possa ser recuperado mesmo que alguns bits sejam corrompidos.
- **Redundância de tempo:** Sistema projetado de tal forma que ações podem ser executadas novamente em caso de falhas. Tipicamente usado para falhas transientes ou intermitentes.
- **Redundância física:** Uso de equipamentos e/ou processos adicionais, de forma que alguns deles possam falhar sem afetar o sistema como um todo. Tipo de redundância mais comum em sistemas distribuídos.

## Resiliência de processos
**Ideia básica:**

- O objetivo é proteger o sistema contra falhas de processos através da replicação de processos.
- Os processos são organizados em grupos de processos para aumentar a robustez e a tolerância a falhas.
- Esses grupos podem ser de dois tipos: planos ou hierárquicos.

![[Pasted image 20240623163105.png]]

Tipos de grupos:
1. **Grupos Planos (Flat Groups):**
    
    - Todos os processos no grupo têm o mesmo nível hierárquico.
    - A comunicação e a coordenação entre os processos são feitas de maneira uniforme, sem distinção de papéis.
    - **Vantagem:** Simplicidade na gestão e na comunicação entre os processos.
    - **Desvantagem:** Pode ser menos eficiente em termos de escalabilidade e gerenciamento de grandes grupos de processos.

1. **Grupos Hierárquicos (Hierarchical Groups):**
    
    - Os processos são organizados em uma estrutura hierárquica com diferentes níveis de autoridade e responsabilidade.
    - Normalmente, há um coordenador (coordinator) no topo da hierarquia que gerencia e coordena os processos subordinados (workers).
    - **Vantagem:** Melhor escalabilidade e eficiência na gestão de grandes grupos. O coordenador gerencia os processos de forma eficiente
    - **Desvantagem:** Pode ser mais complexo de implementar e gerenciar.

A resiliência de processos é alcançada através da replicação e organização dos processos em grupos. A escolha entre um grupo plano ou hierárquico depende das necessidades específicas do sistema, como simplicidade, escalabilidade e eficiência de gerenciamento. Gerenciar a entrada e saída de processos é crucial para manter a resiliência e a robustez do sistema.

### Grupos e mascaramento de falhas

Grupo com grau de tolerância k: Grupo capaz de mascarar até k processos falhando ao mesmo tempo.

Qual deve ser o tamanho do grupo para ter grau de tolerância k?
- **Considerando falhas de parada ou omissão:** são necessários  k + 1  membros no grupo. Nenhum membro produzirá resultado incorreto, então basta termos ao menos uma resposta.
- **Considerando falhas arbitrárias:** são necessários 2k + 1 membros. Resultado correto obtido através de votação da maioria.
	- Se k processos falham arbitráriamente, a maioria tem que estar correta. Ou seja, k+1 não podem estar errados

Hipóteses
- Todos os membros são idênticos.
- Todos os membros processam comandos na mesma ordem.

**Resultado:** podemos afirmar que todos os processos executam exatamente a mesma coisa.

### Consenso

Pré-requisito:
Dentro do grupo, cada processo que está funcionando (não está em falha) executa os mesmos comandos e na mesma ordem.

Reformulação:
Deve haver consenso entre os membros que não estão em falha a respeito de qual comando será o próximo a ser executado.


#### Consenso baseado em flooding

![[Pasted image 20240623164439.png]]
![[Pasted image 20240623164824.png]]

- **Decisão de P2:**
    - Como P2 recebeu todos os comandos propostos, ele está em uma posição de tomar uma decisão.
- **Indecisão de P3 e P4:**
    - Mesmo que P3 tenha detectado a falha de P1, ele não pode garantir que todos os processos restantes têm a mesma visão. Portanto, P3 e P4 não podem tomar uma decisão até que estejam certos de que todos têm as mesmas informações.

## Protocolo Raft
#### Desenvolvido para Compreensibilidade

- **Eleição de Líder:** Utiliza um mecanismo simples de eleição de líder. O líder atual opera durante o "termo atual".
- **Log das Operações:** Cada servidor (geralmente 5) mantém um log das operações, algumas das quais já foram efetuadas. Um servidor de backup não vota em um novo líder se o seu próprio log for mais recente.
- **Posição das Operações:** Todas as operações efetuadas têm a mesma posição no log de cada um dos servidores.
- **Decisão das Operações:** O líder decide qual operação pendente será a próxima a ser efetuada, utilizando uma abordagem baseada em primário.

### Processando Novas Requisições

1. **Envio de Requisição:** Um cliente envia uma requisição para efetuar a operação.
2. **Adição ao Log:** O líder adiciona a requisição ao seu log, registrando o termo atual e o índice.
3. **Envio aos Servidores:** O log é enviado para todos os outros servidores.
4. **Confirmação:** Os outros servidores copiam o log e confirmam o recebimento.
5. **Efetuação da Operação:** Quando a maioria dos servidores confirmarem, o líder efetua a operação e a resposta pode ser enviada ao cliente.

#### Nota

Na prática, apenas atualizações são transmitidas. No final, cada servidor tem a mesma visão e sabe sobre as operações efetuadas. As informações nos servidores de backup são sobrescritas pelas informações do líder se necessário.

### Raft: Falha do Líder

![[Pasted image 20240623165649.png]]

#### Processo de Falha

1. **Detecção da Falha:** O novo líder será aquele que tiver o maior número de operações efetuadas em seu log.
2. **Recepção das Cópias:** Os outros servidores de backup receberão uma cópia da versão mais recente eventualmente.

### Conclusão

O Protocolo Raft simplifica o consenso em sistemas distribuídos utilizando a eleição de um líder que coordena as operações. Cada servidor mantém um log consistente das operações e, em caso de falha do líder, um novo líder é eleito com base no log mais atualizado. O processo de replicação e confirmação das operações garante a consistência e a disponibilidade dos dados no sistema.


# Aula 24
![[aula24.pdf]]


## Consenso realista: Paxos

### Pressupostos (relativamente fracos e realistas)
- Um sistema parcialmente síncrono (pode ser até mesmo assíncrono).
- Comunicação entre processos pode ser não confiável: mensagens podem ser perdidas, duplicadas ou reordenadas.
- Mensagens corrompidas podem ser detectadas (e, portanto, ignoradas).
- Todas as operações são determinísticas: uma vez que uma execução seja iniciada, sabe-se exatamente o que ela fará.
- Processos podem apresentar falhas de crash, mas não falhas arbitrárias.
- Processos não agem em conluio.


### Fundamentos
![[Pasted image 20240623180037.png]]


## Exemplo com dois servidores

![[Pasted image 20240623180134.png]]

## Lidando com mensagens perdidas

![[Pasted image 20240623180327.png]]

## Dois servidores e um crash: problema

![[Pasted image 20240623180431.png]]

## Dois servidores e um crash: solução
![[Pasted image 20240623180504.png]]


## Três servidores e duas falhas: ainda é problema?
![[Pasted image 20240623180614.png]]

## Paxos

Regra geral: Um servidor S não pode executar uma operação o até que tenha recebido uma LEARN(o) de todos os outros servidores não defeituosos


### Detecção de falhas
![[Pasted image 20240623180923.png]]

### Número necessário de servidores

Paxos precisa de pelo menos três servidores

Regra fundamental adaptada: No Paxos com três servidores, um servidor S não pode executar uma operação oaté que tenha recebido **pelo menos uma (outra)** mensagem LEARN(o), para saber que a maioria dos servidores executará o.

Pressupostos:
* inicialmente S1 é o lider
* Um servidor pode dectectar de forma confiável que perdeu uma mensagem e se recuperar dessa perda
* Quando um novo lider precisa ser eleito, os servidores restantes seguem um algoritmo estritamente determinístico, e.g S1 -> S2 -> S3
* Um cliente não pode ser solicitado a ajudar os servidores a resolver uma situação

OBS: Se qualquer um dos backups (S2 ou S3) falhar, o Paxos se comportará corretamente: operações nos servidores não defeituosos são executadas na mesma ordem.

![[Pasted image 20240623181528.png]]
![[Pasted image 20240623181545.png]]
![[Pasted image 20240623181609.png]]
![[Pasted image 20240623181634.png]]



# Aula 25
![[aula25.pdf]]


## Consenso sob semântica de falhas arbitrárias 

Essência: Consideramos grupos de processos nos quais a comunicação entre processos é inconsistente

![[Pasted image 20240623181914.png]]

Quem está falando a verdade?

![[Pasted image 20240623182456.png]]
![[Pasted image 20240623182515.png]]




Subordinado 1 não consegue decidir qual ordem seguir e quem é o traidor - solução: n>= 3m + 1

![[Pasted image 20240623182748.png]]
![[Pasted image 20240623182757.png]]



Modelo de sistema:

- Consideramos um primário P e n-1 backups B1, B2, ..., Bn-1.
- Um cliente envia v ∈ {T, F} para P.
- Mensagens podem ser perdidas, mas isso pode ser detectado.
- Mensagens não podem ser corrompidas de forma indetectável.
- Um receptor de uma mensagem pode detectar seu remetente de forma confiável.


## Acordo Bizantino

#### Requisitos:

**BA1:** Todo processo de backup não falho armazena o mesmo valor.

- **Comentário:** Isso garante que, em caso de falha de alguns servidores, os servidores restantes ainda manterão a consistência dos dados.
- **Exemplo:** Se três servidores backups devem armazenar o valor "X" e um deles falha, os outros dois ainda armazenarão "X".

**BA2:** Se o primário não falhar, então todo processo de backup não falho armazena exatamente o que o primário enviou.

- **Comentário:** Este requisito assegura que a integridade dos dados é mantida quando o servidor primário está funcionando corretamente.
- **Exemplo:** Se o primário envia o valor "Y" e não falha, todos os backups não falhos devem armazenar "Y".

#### Observações:

- **Primário falho:** BA1 diz que os backups armazenam o mesmo valor, porém potencialmente diferente do valor originalmente enviado pelo cliente (e portanto errado).
    
    - **Comentário:** Isso significa que, se o servidor primário falhar e enviar um valor incorreto, os backups irão armazenar esse valor incorreto, mas ainda assim estarão consistentes entre si.
    - **Exemplo:** Se o cliente envia "A", mas o primário falha e envia "B", todos os backups não falhos armazenarão "B".
- **Primário não falho:** Satisfazer BA2 implica que BA1 é satisfeito.
    
    - **Comentário:** Se o primário está funcionando corretamente, então a integridade dos dados está garantida e todos os backups armazenarão o mesmo valor correto.
    - **Exemplo:** Se o cliente envia "C" e o primário não falha, então todos os backups não falhos armazenarão "C", cumprindo tanto BA1 quanto BA2.

### Resumo:

O acordo bizantino é uma técnica crucial em sistemas distribuídos para garantir a consistência e integridade dos dados mesmo em casos de falhas de servidores. Os requisitos BA1 e BA2 garantem que, independentemente das falhas, os servidores não defeituosos mantenham um estado consistente e correto.

### Por que 3k + 1 processos?

![[Pasted image 20240623183827.png]]
![[Pasted image 20240623183855.png]]

### Tolerância a Falhas Bizantinas Práticas (TFBP)
#### Background

Uma das primeiras soluções que conseguiu tolerância a falhas bizantinas mantendo o desempenho aceitável.

#### Pressupostos

- Um servidor pode apresentar falhas arbitrárias.
- Mensagens podem ser perdidas, atrasadas e recebidas fora de ordem.
- Mensagens têm um remetente identificável (ou seja, são assinadas).
- Modelo de execução parcialmente síncrono.

#### Essência

Uma abordagem de primário-backup com 3k + 1 servidores.

![[Pasted image 20240623184324.png]]
![[Pasted image 20240623184334.png]]
![[Pasted image 20240623184359.png]]
![[Pasted image 20240623184411.png]]

## Teorema CAP
Qualqeur sistema de rede que fornece dados compartilhados pode fornecer apenas duas das seguintes 3 propriedades:
* Consistência (C): pela qual um item de dados compartilhado e replicado aparece como uma única cópia atualizada
* Disponibilidade (D): pela qual as atualizações serão sempre eventualmente executadas
* Particionamento (P): Tolerância ao particionamento do grupo de processos

Conclusão:
Em uma rede sujeita a falhas de comunicação, é impossível implementar uma memória compartilhada com leitura e escrita atômicas que garanta uma resposta a todas as solicitações.

![[Pasted image 20240623185112.png]]

## Detecção de falhas
![[Pasted image 20240623185301.png]]
![[Pasted image 20240623185327.png]]






# Aula 26
![[aula26.pdf]]